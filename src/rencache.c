#include <stdlib.h>
#include <stddef.h>
#include <stdint.h>
#include <stdio.h>
#include <stdbool.h>
#include <stdlib.h>
#include <string.h>

#ifdef _MSC_VER
  #ifndef alignof
    #define alignof _Alignof
  #endif
  /* max_align_t is a compiler defined type, but
  ** MSVC doesn't provide it, so we'll have to improvise */
  typedef long double max_align_t;
#else
  #include <stdalign.h>
#endif

#include <lauxlib.h>
#include "rencache.h"
#include "renwindow.h"

/* a cache over the software renderer -- all drawing operations are stored as
** commands when issued. At the end of the frame we write the commands to a grid
** of hash values, take the cells that have changed since the previous frame,
** merge them into dirty rectangles and redraw only those regions */

#define CMD_BUF_RESIZE_RATE 1.2
#define CMD_BUF_INIT_SIZE (1024 * 512)
#define COMMAND_BARE_SIZE offsetof(Command, command)

enum CommandType { SET_CLIP, DRAW_TEXT, DRAW_RECT, DRAW_POLY, DRAW_CANVAS };

typedef struct {
  enum CommandType type;
  uint32_t size;
  /* Commands *must* always begin with a RenRect
  ** This is done to ensure alignment */
  RenRect command[];
} Command;

typedef struct {
  RenRect rect;
} SetClipCommand;

typedef struct {
  RenRect rect;
  RenColor color;
  RenFont *fonts[FONT_FALLBACK_MAX];
  float text_x;
  size_t len;
  int8_t tab_size;
  RenTab tab;
  char text[];
} DrawTextCommand;

typedef struct {
  RenRect rect;
  RenColor color;
} DrawRectCommand;

typedef struct {
  RenRect rect;
  RenColor color;
  unsigned short npoints;
  RenPoint points[];
} DrawBezierCommand;

typedef struct {
  RenRect rect;
  size_t version;
  RenCanvasRef *canvas_ref;
} DrawCanvasCommand;

static bool show_debug = false;

static inline int rencache_min(int a, int b) { return a < b ? a : b; }
static inline int rencache_max(int a, int b) { return a > b ? a : b; }


/* 32bit fnv-1a hash */
#define HASH_INITIAL 2166136261

static void hash(unsigned *h, const void *data, int size) {
  const unsigned char *p = data;
  while (size--) {
    *h = (*h ^ *p++) * 16777619;
  }
}


static inline int cell_idx(int x, int y) {
  return x + y * RENCACHE_CELLS_X;
}


static inline bool rects_overlap(RenRect a, RenRect b) {
  return b.x + b.width  >= a.x && b.x <= a.x + a.width
      && b.y + b.height >= a.y && b.y <= a.y + a.height;
}


static RenRect intersect_rects(RenRect a, RenRect b) {
  int x1 = rencache_max(a.x, b.x);
  int y1 = rencache_max(a.y, b.y);
  int x2 = rencache_min(a.x + a.width, b.x + b.width);
  int y2 = rencache_min(a.y + a.height, b.y + b.height);
  return (RenRect) { x1, y1, rencache_max(0, x2 - x1), rencache_max(0, y2 - y1) };
}


static RenRect merge_rects(RenRect a, RenRect b) {
  int x1 = rencache_min(a.x, b.x);
  int y1 = rencache_min(a.y, b.y);
  int x2 = rencache_max(a.x + a.width, b.x + b.width);
  int y2 = rencache_max(a.y + a.height, b.y + b.height);
  return (RenRect) { x1, y1, x2 - x1, y2 - y1 };
}

static bool expand_command_buffer(RenCache *ren_cache) {
  size_t new_size = ren_cache->command_buf_size * CMD_BUF_RESIZE_RATE;
  if (new_size == 0) {
    new_size = CMD_BUF_INIT_SIZE;
  }
  uint8_t *new_command_buf = SDL_realloc(ren_cache->command_buf, new_size);
  if (!new_command_buf) {
    return false;
  }
  ren_cache->command_buf_size = new_size;
  ren_cache->command_buf = new_command_buf;
  return true;
}

static void* push_command(RenCache *ren_cache, enum CommandType type, int size) {
  if (!ren_cache || ren_cache->resize_issue) {
    // Don't push new commands as we had problems resizing the command buffer.
    // Or, we don't have an active buffer.
    // Let's wait for the next frame.
    return NULL;
  }
  size_t alignment = alignof(max_align_t) - 1;
  size += COMMAND_BARE_SIZE;
  size = (size + alignment) & ~alignment;
  int n = ren_cache->command_buf_idx + size;
  while (n > ren_cache->command_buf_size) {
    if (!expand_command_buffer(ren_cache)) {
      fprintf(stderr, "Warning: (" __FILE__ "): unable to resize command buffer (%zu)\n",
              (size_t)(ren_cache->command_buf_size * CMD_BUF_RESIZE_RATE));
      ren_cache->resize_issue = true;
      return NULL;
    }
  }
  Command *cmd = (Command*) (ren_cache->command_buf + ren_cache->command_buf_idx);
  ren_cache->command_buf_idx = n;
  memset(cmd, 0, size);
  cmd->type = type;
  cmd->size = size;
  return cmd->command;
}


static bool next_command(RenCache *ren_cache, Command **prev) {
  if (*prev == NULL) {
    *prev = (Command*) ren_cache->command_buf;
  } else {
    *prev = (Command*) (((char*) *prev) + (*prev)->size);
  }
  return *prev != ((Command*) (ren_cache->command_buf + ren_cache->command_buf_idx));
}


void rencache_init(RenCache *rc) {
  memset(rc, 0, sizeof(RenCache));
  rc->window = NULL;
  rc->rensurface.surface = NULL;
#ifdef PRAGTICAL_USE_SDL_RENDERER
  rc->texture = NULL;
  rc->renderer = NULL;
#endif
  rc->command_buf = NULL;
  rc->command_buf_idx = 0;
  rc->command_buf_size = 0;
  rc->cells_prev = rc->cells_buf1;
  rc->cells = rc->cells_buf2;
}


void rencache_uninit(RenCache *rc) {
  if (rc) {
    if (rc->command_buf)
      SDL_free(rc->command_buf);
    rencache_init(rc);
  }
}


void rencache_show_debug(bool enable) {
  show_debug = enable;
}


void rencache_set_clip_rect(RenCache *ren_cache, RenRect rect) {
  SetClipCommand *cmd = push_command(ren_cache, SET_CLIP, sizeof(SetClipCommand));
  if (cmd) {
    cmd->rect = intersect_rects(rect, ren_cache->screen_rect);
    ren_cache->last_clip_rect = cmd->rect;
  }
}


void rencache_draw_rect(RenCache *ren_cache, RenRect rect, RenColor color) {
  if (rect.width == 0 || rect.height == 0 || !rects_overlap(ren_cache->last_clip_rect, rect)) {
    return;
  }
  DrawRectCommand *cmd = push_command(ren_cache, DRAW_RECT, sizeof(DrawRectCommand));
  if (cmd) {
    cmd->rect = rect;
    cmd->color = color;
  }
}

double rencache_draw_text(RenCache *ren_cache, RenFont **fonts, const char *text, size_t len, double x, double y, RenColor color, RenTab tab)
{
  int x_offset;
  double width = ren_font_group_get_width(fonts, text, len, tab, &x_offset);
  RenRect rect = { x + x_offset, y, (int)(width - x_offset), ren_font_group_get_height(fonts) };
  if (rects_overlap(ren_cache->last_clip_rect, rect)) {
    int sz = len + 1;
    DrawTextCommand *cmd = push_command(ren_cache, DRAW_TEXT, sizeof(DrawTextCommand) + sz);
    if (cmd) {
      memcpy(cmd->text, text, sz);
      cmd->color = color;
      memcpy(cmd->fonts, fonts, sizeof(RenFont*)*FONT_FALLBACK_MAX);
      cmd->rect = rect;
      cmd->text_x = x;
      cmd->len = len;
      cmd->tab_size = ren_font_group_get_tab_size(fonts);
      cmd->tab = tab;
    }
  }
  return x + width;
}

RenRect rencache_draw_poly(RenCache *ren_cache, RenPoint *points, int npoints, RenColor color) {
  RenRect rect;
  if (ren_poly_cbox(points, npoints, &rect) != 0) {
    return (RenRect){-1};
  }
  if (rects_overlap(ren_cache->last_clip_rect, rect)) {
    size_t size = npoints + npoints * sizeof(RenPoint);
    DrawBezierCommand *cmd = push_command(ren_cache, DRAW_POLY, sizeof(DrawBezierCommand) + size);
    if (cmd) {
      cmd->rect = rect;
      cmd->color = color;
      cmd->npoints = npoints;
      memcpy(cmd->points, points, npoints * sizeof(RenPoint));
    }
  }
  return rect;
}

void rencache_draw_canvas(RenWindow *window_renderer, RenRect rect, RenCanvasRef *canvas_ref, size_t version) {
  if (rect.width == 0 || rect.height == 0 || !rects_overlap(last_clip_rect, rect)) {
    return;
  }
  DrawCanvasCommand *cmd = push_command(window_renderer, DRAW_CANVAS, sizeof(DrawCanvasCommand));
  if (cmd) {
    cmd->rect = rect;
    cmd->version = version;
    cmd->canvas_ref = canvas_ref;
    canvas_ref->render_ref_count++;
  }
}

void rencache_invalidate(RenCache *ren_cache) {
  memset(ren_cache->cells_prev, 0xff, sizeof(ren_cache->cells_buf1));
}


void rencache_begin_frame(RenCache *ren_cache) {
  /* reset all cells if the screen width/height has changed */
  int w, h;
  ren_cache->resize_issue = false;
  RenSurface rs = rencache_get_surface(ren_cache);
  ren_get_size(&rs, &w, &h);
  if (ren_cache->screen_rect.width != w || h != ren_cache->screen_rect.height) {
    ren_cache->screen_rect.width = w;
    ren_cache->screen_rect.height = h;
    rencache_invalidate(ren_cache);
  }
  ren_cache->last_clip_rect = ren_cache->screen_rect;
}


static void update_overlapping_cells(RenCache *ren_cache, RenRect r, unsigned h) {
  int x1 = r.x / RENCACHE_CELL_SIZE;
  int y1 = r.y / RENCACHE_CELL_SIZE;
  int x2 = (r.x + r.width) / RENCACHE_CELL_SIZE;
  int y2 = (r.y + r.height) / RENCACHE_CELL_SIZE;

  for (int y = y1; y <= y2; y++) {
    for (int x = x1; x <= x2; x++) {
      int idx = cell_idx(x, y);
      hash(&ren_cache->cells[idx], &h, sizeof(h));
    }
  }
}


static void push_rect(RenCache *ren_cache, RenRect r, int *count) {
  /* try to merge with existing rectangle */
  for (int i = *count - 1; i >= 0; i--) {
    RenRect *rp = &ren_cache->rect_buf[i];
    if (rects_overlap(*rp, r)) {
      *rp = merge_rects(*rp, r);
      return;
    }
  }
  /* couldn't merge with previous rectangle: push */
  ren_cache->rect_buf[(*count)++] = r;
}


void rencache_end_frame(RenCache *ren_cache) {
  /* update cells from commands */
  Command *cmd = NULL;
  RenRect cr = ren_cache->screen_rect;
  while (next_command(ren_cache, &cmd)) {
    /* cmd->command[0] should always be the Command rect */
    if (cmd->type == SET_CLIP) {
      SetClipCommand *ccmd = (SetClipCommand*)&cmd->command;
      cr = ccmd->rect;
    } else if (cmd->type == DRAW_CANVAS) {
      // We unref here because it's the only place where the command is scanned once,
      // and won't give back control to the Lua side until it's done with the surface
      DrawCanvasCommand *cvcmd = (DrawCanvasCommand*)&cmd->command;
      cvcmd->canvas_ref->render_ref_count--;
    }
    RenRect r = intersect_rects(cmd->command[0], cr);
    if (r.width == 0 || r.height == 0) { continue; }
    unsigned h = HASH_INITIAL;
    hash(&h, cmd, cmd->size);
    update_overlapping_cells(ren_cache, r, h);
  }

  /* push rects for all cells changed from last frame, reset cells */
  int rect_count = 0;
  int max_x = ren_cache->screen_rect.width / RENCACHE_CELL_SIZE + 1;
  int max_y = ren_cache->screen_rect.height / RENCACHE_CELL_SIZE + 1;
  for (int y = 0; y < max_y; y++) {
    for (int x = 0; x < max_x; x++) {
      /* compare previous and current cell for change */
      int idx = cell_idx(x, y);
      if (ren_cache->cells[idx] != ren_cache->cells_prev[idx]) {
        push_rect(ren_cache, (RenRect) { x, y, 1, 1 }, &rect_count);
      }
      ren_cache->cells_prev[idx] = HASH_INITIAL;
    }
  }

  /* expand rects from cells to pixels */
  for (int i = 0; i < rect_count; i++) {
    RenRect *r = &ren_cache->rect_buf[i];
    r->x *= RENCACHE_CELL_SIZE;
    r->y *= RENCACHE_CELL_SIZE;
    r->width *= RENCACHE_CELL_SIZE;
    r->height *= RENCACHE_CELL_SIZE;
    *r = intersect_rects(*r, ren_cache->screen_rect);
  }

  RenSurface rs = rencache_get_surface(ren_cache);
  /* redraw updated regions */
  for (int i = 0; i < rect_count; i++) {
    /* draw */
    RenRect r = ren_cache->rect_buf[i];
    ren_set_clip_rect(&rs, r);

    cmd = NULL;
    while (next_command(ren_cache, &cmd)) {
      SetClipCommand *ccmd = (SetClipCommand*)&cmd->command;
      DrawRectCommand *rcmd = (DrawRectCommand*)&cmd->command;
      DrawTextCommand *tcmd = (DrawTextCommand*)&cmd->command;
      DrawBezierCommand *bcmd = (DrawBezierCommand*)&cmd->command;
      DrawCanvasCommand *cvcmd = (DrawCanvasCommand*)&cmd->command;
      switch (cmd->type) {
        case SET_CLIP:
          ren_set_clip_rect(&rs, intersect_rects(ccmd->rect, r));
          break;
        case DRAW_RECT:
          ren_draw_rect(&rs, rcmd->rect, rcmd->color, false);
          break;
        case DRAW_TEXT:
          ren_font_group_set_tab_size(tcmd->fonts, tcmd->tab_size);
          ren_draw_text(&rs, tcmd->fonts, tcmd->text, tcmd->len, tcmd->text_x, tcmd->rect.y, tcmd->color, tcmd->tab);
          break;
        case DRAW_POLY:
          ren_draw_poly(&rs, bcmd->points, bcmd->npoints, bcmd->color);
          break;
        case DRAW_CANVAS:
          ren_draw_canvas(&rs, cvcmd->canvas_ref->surface, cvcmd->rect.x, cvcmd->rect.y);
      }
    }

    if (show_debug) {
      RenColor color = { rand(), rand(), rand(), 50 };
      ren_draw_rect(&rs, r, color, false);
    }
  }

  /* update dirty rects */
  if (rect_count > 0 && ren_cache->window) {
    rencache_update_rects(ren_cache, ren_cache->rect_buf, rect_count);
  }

  /* swap cell buffer and reset */
  unsigned *tmp = ren_cache->cells;
  ren_cache->cells = ren_cache->cells_prev;
  ren_cache->cells_prev = tmp;
  ren_cache->command_buf_idx = 0;
}

RenSurface rencache_get_surface(RenCache *ren_cache) {
#ifdef PRAGTICAL_USE_SDL_RENDERER
  return ren_cache->rensurface;
#else
  if (ren_cache->window) {
    SDL_Surface *surface = SDL_GetWindowSurface(ren_cache->window);
    if (!surface) {
      fprintf(stderr, "Error getting window surface: %s", SDL_GetError());
      exit(1);
    }
    return (RenSurface){.surface = surface, .scale_x = 1, .scale_y = 1};
  } else if (!ren_cache->rensurface.surface) {
    fprintf(stderr, "RenCache surface not initialized");
    exit(1);
  }
  return ren_cache->rensurface;
#endif
}


void rencache_update_rects(RenCache *rc, RenRect *rects, int count) {
  // TODO: Does not work nicely with multiple windows
  static bool initial_window = true;
  if (rc->window){
#ifdef PRAGTICAL_USE_SDL_RENDERER
    const float scale_x = rc->rensurface.scale_x;
    const float scale_y = rc->rensurface.scale_y;
    for (int i = 0; i < count; i++) {
      const RenRect *r = &rects[i];
      const int x = scale_x * r->x, y = scale_y * r->y;
      const int w = scale_x * r->width, h = scale_y * r->height;
      const SDL_Rect sr = {.x = x, .y = y, .w = w, .h = h};
      uint8_t *pixels = ((uint8_t *) rc->rensurface.surface->pixels) + y * rc->rensurface.surface->pitch + x * SDL_BYTESPERPIXEL(rc->rensurface.surface->format);
      SDL_UpdateTexture(rc->texture, &sr, pixels, rc->rensurface.surface->pitch);
    }
    SDL_RenderTexture(rc->renderer, rc->texture, NULL, NULL);
    SDL_RenderPresent(rc->renderer);
#else
    SDL_UpdateWindowSurfaceRects(rc->window, (SDL_Rect*) rects, count);
#endif
    if (initial_window) {
      SDL_ShowWindow(rc->window);
      initial_window = false;
    }
  }
}
